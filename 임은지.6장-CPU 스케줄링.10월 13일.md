# CPU 스케줄링
`CPU(Central Processing Unit)`는 프로그램의 기계어 명령을 실제로 수행하는 컴퓨터 내의 중앙 처리장치이다.

### 기계어 명령
#### CPU 내에서 수행되는 명령
- Add 명령 : CPU 내의 레지스터에 있는 두 값을 더해 레지스터에 저장하는 명령
#### 메모리 접근을 필요로 하는 명령
- Load 명령 : 메모리에 있는 데이터를 CPU로 읽어들이는 명령
- Store 명령 : CPU에서 계산된 결과값을 메모리에 저장하는 명령
#### 입출력을 동반하는 명령
- 특권명령으로 규정
- 프로그램이 직접 수행 불가하고 운영체제를 통해 서비스를 대행하도록 되어있음

### 사용자 프로그램이 수행되는 과정
CPU 작업과 I/O 작업의 반복으로 구성
#### CPU 버스트
- 사용자 프로그램이 CPU를 직접 가지고 빠른 명령을 수행하는 일련의 단계
#### I/O 버스트
- I/O 요청이 발생해 커널에 의해 입출력 작업을 진행하는 비교적 느린 단계
![CPU 버스트와 I/O 버스트의 모습](https://velog.velcdn.com/images/zzallang/post/483f8047-8e5d-4a68-b9ba-ae49e01ea0ea/image.png)

각 프로그램마다 CPU 버스트와 I/O 버스트가 차지하는 비율이 균일하지는 않다. 프로세스는
#### CPU 바운드 프로세스
- I/O 작업을 거의 수행하지 않아 CPU 버스트가 길게 나타나는 프로세스
- 프로세스 수행의 상당 시간을 입출력 작업 없이 CPU 작업에 소모하는 계산 위주의 프로그램
#### I/O 바운드 프로세스
- I/O 요청이 빈번해 CPU 버스트가 짧게 나타나는 프로세스
- 사용자로부터 인터랙션(interaction)을 계속 받아가며 프로그램을 수행시키는 대화형 프로그램 (interactive program)

대화형 작업은 사용자에 대한 빠른 응답이 중요함. 따라서 CPU 스케줄링을 할 때 CPU 버스트가 짧은 프로세스에게 우선적으로 CPU를 사용할 수 있도록 하는 스케줄링이 필요하다. CPU 스케줄링 시 I/O 바운드 프로세스의 우선순위를 높여주는 것이 바람직하다는 의미이다.

![CPU 버스트의 분포도](https://velog.velcdn.com/images/zzallang/post/ab1f9f1c-efbc-43b9-a13d-9243a120a751/image.png)

## 1. CPU 스케줄러
- 준비 상태에 있는 프로세스들 중 어떠한 프로세스에게 CPU를 할당할지 결정하는 운영체제이 코드

### 스케줄링이 필요한 경우
① 실행 상태에 있던 프로세스가 I/O 요청 등에 의해 봉쇄(blocked)상태로 바뀌는 경우
② 실행 상테에 있던 프로세스가 타이머 인터럽트 발생에 의해 준비 상태로 바뀌는 경우
③ I/O 요청으로 봉쇄 상태에 있던 프로세스의 I/O 작업이 완료되어 인터럽트가 발생하고 그 결과 이 프로세스의 상태가 준비상태로 바뀌는 경우
④ CPU에서 실행 상태에 있는 프로세스가 종료되는 경우
### CPU 스케줄링 방식
#### 비선점형(nonpreemptive)
- CPU를 획득한 프로세스가 스스로 CPU를 반납하기 전까지는 CPU를 빼앗기지 않는 방법
- ①과 ④가 대표적인 예
#### 선점형(preemptive)
- 프로세스가 CPU를 계속 사용하기를 원하더라도 강제로 빼앗을 수 있는 스케줄링 방법
- ②와 ③이 대표적인 예
***
## 2. 디스패처
- 새롭게 선택된 프로세스가 CPU를 할당받고 작업을 수행할 수 있도록 환경설정을 하는 운영체제의 코드
- 현재 수행 중이던 프로세스의 문맥을 그 프로세스의 PCB에 저장
- 새롭게 선택된 프로세스의 문맥을 PCB로부터 복원
- 그 프로세스에서 CPU를 넘기는 과정을 수행
#### 디스패치 지연시간(dispatch latency)
디스패처가 하나의 프로세스를 정지시키고 다르프로세스에게 CPU를 전달하기까지 걸리는 시간

디스패치 지연시간의 대부분은 문맥교환 `오버헤드`에 해당된다
***
## 3. 스케줄링의 성능 평가
스케줄링 기법의 성능을 평가하기 위한 지표
### 시스템 관점의 지표
#### CPU 이용률(CPU utilization)
- 전체 시간 중에서 CPU가 일을 한 시간의 비율
- 시스템 전체의 성능과 밀접하게 관련
- CPU가 일을 하지 않고 휴면(idle) 상태에 머무르는 시간을 최대한 줄이는 것이 스케줄링의 중요한 목표
#### 처리량(throughput)
- 주어진 시간 동안 준비 큐에서 기다리고 있는 프로세스 중 몇 개를 끝마쳤는지(CPU 버스트를 완료한 프로세스의 개수)를 나타냄
- 여러 프로세스가 CPU를 기다리고 있는 상황에서 주어진 시간에 더 많은 프로세스들이 CPU 작업을 완료하기 위해서는 CPU 버스트가 짧은 프로세스에게 우선적으로 CPU를 할당하는 것이 유리하다.
### 사용자 관점의 지표
#### 소요시간(turnaround time)
- 프로세스가 CPU를 요청한 시점부터 자신이 원하는 만큼 CPU를 다 쓰고 CPU 버스트가 끝날 때까지 걸린 시간
- 준비큐가 기다린 시간 + 실제로 CPU를 사용한 시간
   - ※주의
  프로그램이 시작해서 종료하는 데까지 걸리는 시간이 아님
#### 대기시간(waiting time)
- CPU 버스트 기간 중 프로세스가 준비 큐에서 CPU를 얻기 위해 기다린 시간의 합
#### 응답시간(response time)
- 프로세스가 준비 큐에 들어온 후 첫 번째 CPU를 획득하기까지 기다린 시간
- 타이머 인터럽트가 빈번히 발생할수록 각 프로세스가 CPU를 연속적으로 사용할 수 있는 시간이 짧아지므로 처음 CPU를 얻기까지 걸리는 시간을 줄어줄게 되어 응답시간이 향상됨.
- 대화형 시스템에 정합한 성능 척도로 사용자 입장에서 중요한 성능 척도
***
## 4. 스케줄링 알고리즘
### 1) 선입선출 스케줄링(First-Come First-Served: FCFS)
> 준비된 프로세스가 준비 큐에 도착한 시간 순서대로 CPU를 할당하는 방식

- CPU를 먼저 요청한 프로세스에세 CPU를 먼저 할당
- 프로세스마다 소요되는 시간의 편차가 매우 큼
- 대단히 합리적인 것 같지만 비효율적인 결과를 초래
### 2) 최단작업 우선 스케줄링(Shortest-Job First: SJF)
> CPU 버스트가 가장 짧은 프로세스에게 제일 먼저 CPU를 할당하는 방식
SRTF(Shortest Remaining Time First)라고도 부른다.

#### 비선점형 방식
- 일단 CPU를 획득하면 그 프로세스가 CPU를 자진 반납하기 전까지는 CPU를 빼앗지 않는 방식
#### 선점형 방식
- CPU 버스트가 더 짧은 프로세스가 도착할 경우 CPU를 빼앗아 더 짧은 프로세스에게 할당하는 방식
- 프로세스들이 준비 큐에 도착하는 불규칙한 환경에서는 선점형 방식이 프로세스들의 평균 대기시간을 최소화하는 최적의 알고리즘
- 단점 : 기아현상
   - CPU 버스트가 짧은 프로세스에게만 CPU를 할당할 경우 CPU 버스트가 긴 프로세스는 준비 큐에 줄 서서 무한정 기다려야 하는 문제가 발생하는 현상
### 3) 우선순위 스케줄링(priority scheduling)
> 준비 큐에서 기다리는 프로세스들 중 우선순위가 가장 높은 프로세스에게 제일 먼저 CPU를 할당하는 방식

- 우선순위 값(priority number)통해 표시하며 우선순위 값이 작을수록 높은 우선순위를 가지는 것으로 가정
- 단점 : 기아현상
   - 해결 : 노화(aging) 기법 사용 : 기다리는 시간이 길어지면 우선순위를 조금씩 높여, 언젠가는 가장 높은 우선순위가 되어 CPU를 할당받을 수 있게 해주는 방법

### 4) 라운드 로빈 스케줄링(Round Robin Scheduling)
> 각 프로세스가 CPU를 연속적으로 사용할 수 있는 시간이 특정 시간으로 제한되며, 이 시간이 경과하면 해당 프로세스로부터 CPU를 회수해 준비 큐에 줄 서 있는 다른 프로세스에게 CPU를 할당하는 방식

- 각 프로세스마다 한 번에 CPU를 연속적으로 사용할 수 있는 최대 시간을`할당시간(time quantum)`이라고 부른다.
- 여러 종류에 이질적인 프로세스가 같이 실행되는 환경에서 효과적
- 대화형 프로세스의 빠른 응답시간을 보장할 수 있음
- 라운드 로빈 스케줄링의 기본적인 목적은 CPU 버스트 시간이 짧은 프로세스가 빨리 CPU를 얻을 수 있도록 하는 동시에, CPU 버스트 시간이 긴 프로세스가 불이익을 당하지 않도록 하는 것
### 5) 멀티레벨 큐(multi-level queue)
> 준비 큐를 여러 개로 분할해 관리하는 스케줄링 기법

- 프로세스들이 CPU를 기다리기 위해 한 줄로 서는 것이 아니라 여러 줄로 서는 것
- 일반적으로 성격이 다른 프로세스들을 별도로 관리하고, 프로세스의 성격에 맞는 스케줄링을 적용하기 위해 준비 큐를 별도로 두게 됨
#### 전위 큐(foreground queue)
- 대화형 작업을 담는 큐
- 라운드 로빈 스케줄링 사용
#### 후위 큐(background queue)
- 계산 위주의 작업을 담는 큐
- FCFS 스케줄링 사용
#### 고정 우선순위 방식(fixed priority scheduling)
- 큐에 고정적인 우선순위를 부여해 우선순위가 높은 큐를 먼저 서비스하고 우선순위가 낮은 큐는 우선순위가 높은 큐가 비어 있을 때에만 서비스하게 됨
- 전위 큐에 있는 프로세스에세 우선적으로 CPU가 할당되고, 전위 큐가 비어 있는 경우에만 후위 큐에 있는 프로세스에게 CPU가 할당 될 수 있는 것
- 큐 자체에 대한 스케줄링이 필요함
   - 타임 슬라이스(time slice) 방식 사용
      - 기아 현상을 해소할 수 있는 방식으로, 각 큐에 CPU 시간을 적절한 비율로 할당
### 6) 멀티레벨 피드백 큐(Multilevel Feedback Queue)
> CPU를 기다리는 프로세스를 여러 큐에 줄 세운다는 측면에서 멀티레벨 큐와 동알하나, 프로세스 하나의 큐에서 다른 큐로 이동이 가능하다는 점이 다름

![멀티레벨 큐의 모습](https://velog.velcdn.com/images/zzallang/post/20d3ef2f-b967-416a-91c0-6b59a4e3d88d/image.jpg)
### 7) 다중처리기 스케줄링(multi-processor system)
> CPU가 여러 개인 시스템이라고 부르며 각 CPU별 부하가 적절히 분산되도록 하는 부하균형(load alancing) 매커니즘을 필요로 함

- 프로세스를 준비 큐에 한 줄로 세워서 각 CPU가 알아서 다음 프로세스를 꺼내어 갈 수 있도록 할 수 있음 
#### 대칭형 다중처리(symmetric multi-processing)
- 각 CPU가 각자 알아서 스케줄링을 결정하는 방식
#### 비대칭형 다중처리(asymmetric multi-processing)
- 하나의 CPU가 다른 모든 CPU의 스케줄링 및 데이터 접근을 책임지고 나머지 CPU는 거기에 따라 움직이는 방식
### 8) 실시간 스케줄링(real-time scheduling)
#### 경성 실시간 시스템(hard real-time system)
- 시간을 정확히 지켜야 하는 시스템
- 정해진 시간안에 반드시 작업이 완료되도록 스케줄링 해야 함
- EDF(Ealrlist Deadline First) 스케줄링 사용
   - 데드라인이 얼마 남지 않는 요청을 먼저 처리하는 방식
#### 연성 실시간 시스템(soft real-time system)
- 데드라인이 존재하지 않음
***
## 5. 스케줄링 알고리즘의 평가
### 큐잉모델(queueing model)
- 주로 이론가들이 수행하는 방식
- 확률 분포를 통해 프로세스들이 도착률과 CPU의 처리율을 입력값으로 주면 복잡한 수학적 계산을 통해 각종 성능지표인 CPU의 처리량, 프로세스의 평균 대기시간 등을 구하게 된다.
### 시뮬레이션(simulation)
- 가상으로 CPU 스케줄링 프로그램을 작성한 후 프로그램의 CPU 요청을 입력값으로 넣어 어떠한 결과가 나오는지를 확인하는 방법
- 이때 실제 시스템에서 추출한 입력값을 `트레이스(trace)`라고 부른다.
   - 트레이스 : 몇 초에 어떤 프로세스가 도착하고, 각각 CPU 버스트 시간을 얼마로 하는지에 대한 정보를 시간 순서대로 적어놓은 파일
### 구현 및 실측(implementation & measurement)
- 이론가와 정반대인 구현가들이 수행할 수 있는 방식
- 운영체제 커널의 소스 코드 중 CPU 스케줄링을 수행하는 코드를 수정해서 커널을 컴파일한 후 시스템에 설치하는 과정을 필요로 함
- 그런 다음 동일한 프로그램을 원래 커널과 CPU 스케줄러를 수정한 커널에서 수행시켜보고 실행시간을 측정하여 알고리즘의 성능을 평가

